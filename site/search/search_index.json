{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Aproximation of ordinary differential equations By Marco Barquero(C30970) and Andres Chacon (C32026) In physics is common to encounter differential equations that have no analitical solution. This kind of differential equations are resolved by using aproximations. An example of one these equations is: \\frac{dy}{dx}=x^4y^2+\\frac{x}{y^3} In general, the methods that will be described in this article can only be used if the differential equations has the form: \\frac{dy}{dx}=f(x,y) For these methods, the equation described before must satisfy two conditions: The function f , must be a function of x and y , so f=f(x,y) . The dependant variable evaluated in x=x_{0} must exist and be a known value. So y(x=x_{0})=y_{0} . The numeric methods for the aproximation of the differential equations are: Euler's method Runge Kutta method of second order Runge Kutta method of fourth order It is important to mention that all these methods have an associated error, the margin of the error is determinated by the magnitude of the 'steps'. The step is the value of the amount of change of the independet variable, in the optimal case these steps would be inifitesimal so the derivative of the function could be calculated, however, it would be impossible to compute an aproximation with infitesimal steps. So, is important to consider the value of the steps acordingly to the method that will be used and the precision required. Euler's method This aproximation is based on the Taylor Series of a function y(x+h) , where h is the 'step' mentiond before. One can assume that the step h is inifitesimal, so the Taylor Series of the function can be aproximated to: y(x+h)=y(x)+hf(x,y) This method is the least precise of the three but is the fastest because requieres just one calculation per iteration. To be as precise as the Runge Kutta method it needs smaller steps and therefore a lot more iterations. Runge Kutta Method The method will be described for second and fourth order. This method requires more time to be computed, but the precision gained in the aproximation is worth it depending on the size of interval and the function f(x,y) . Second Order (RK2) As in Euler's method, this aproximation is obtained from the Taylor Series of a function y(x+h) . The value of the function in a given iteration is decribed by: y(x+h)=y(x)+hk_{2} Where k_{i} are calculated as: k_{1}= f(x,y) k_{2}= f(x+\\frac{h}{2}, y+\\frac{k_{1}}{2}) Fourth Order (RK4) This method is the most precise of the three, if possible, one should use this method. The reason why it is not always viable is because it requieres more calculations per iteration. The aproximation of y(x+h) through this method is: y(x+h)=y(x)+\\frac{h}{6}(k_{1}+2k_{2}+2k_{3}+k_{4}) Where k_{i} are: k_{1} = f(x,y) k_{2} = f(x+\\frac{h}{2}, y+\\frac{k_{1}}{2}) k_{3} = f(x+\\frac{h}{2}, y+\\frac{k_{2}}{2}) k_{4} = f(x+h,y+k_{3})","title":"Aproximation of ordinary differential equations"},{"location":"index.html#aproximation-of-ordinary-differential-equations","text":"By Marco Barquero(C30970) and Andres Chacon (C32026) In physics is common to encounter differential equations that have no analitical solution. This kind of differential equations are resolved by using aproximations. An example of one these equations is: \\frac{dy}{dx}=x^4y^2+\\frac{x}{y^3} In general, the methods that will be described in this article can only be used if the differential equations has the form: \\frac{dy}{dx}=f(x,y) For these methods, the equation described before must satisfy two conditions: The function f , must be a function of x and y , so f=f(x,y) . The dependant variable evaluated in x=x_{0} must exist and be a known value. So y(x=x_{0})=y_{0} . The numeric methods for the aproximation of the differential equations are: Euler's method Runge Kutta method of second order Runge Kutta method of fourth order It is important to mention that all these methods have an associated error, the margin of the error is determinated by the magnitude of the 'steps'. The step is the value of the amount of change of the independet variable, in the optimal case these steps would be inifitesimal so the derivative of the function could be calculated, however, it would be impossible to compute an aproximation with infitesimal steps. So, is important to consider the value of the steps acordingly to the method that will be used and the precision required.","title":"Aproximation of ordinary differential equations"},{"location":"index.html#eulers-method","text":"This aproximation is based on the Taylor Series of a function y(x+h) , where h is the 'step' mentiond before. One can assume that the step h is inifitesimal, so the Taylor Series of the function can be aproximated to: y(x+h)=y(x)+hf(x,y) This method is the least precise of the three but is the fastest because requieres just one calculation per iteration. To be as precise as the Runge Kutta method it needs smaller steps and therefore a lot more iterations.","title":"Euler's method"},{"location":"index.html#runge-kutta-method","text":"The method will be described for second and fourth order. This method requires more time to be computed, but the precision gained in the aproximation is worth it depending on the size of interval and the function f(x,y) .","title":"Runge Kutta Method"},{"location":"index.html#second-order-rk2","text":"As in Euler's method, this aproximation is obtained from the Taylor Series of a function y(x+h) . The value of the function in a given iteration is decribed by: y(x+h)=y(x)+hk_{2} Where k_{i} are calculated as: k_{1}= f(x,y) k_{2}= f(x+\\frac{h}{2}, y+\\frac{k_{1}}{2})","title":"Second Order (RK2)"},{"location":"index.html#fourth-order-rk4","text":"This method is the most precise of the three, if possible, one should use this method. The reason why it is not always viable is because it requieres more calculations per iteration. The aproximation of y(x+h) through this method is: y(x+h)=y(x)+\\frac{h}{6}(k_{1}+2k_{2}+2k_{3}+k_{4}) Where k_{i} are: k_{1} = f(x,y) k_{2} = f(x+\\frac{h}{2}, y+\\frac{k_{1}}{2}) k_{3} = f(x+\\frac{h}{2}, y+\\frac{k_{2}}{2}) k_{4} = f(x+h,y+k_{3})","title":"Fourth Order (RK4)"},{"location":"reference.html","text":"How to use Here is presented general description of how these methods were build as python functions. Its important to mention that to use correctly these methods they need to be used inside a loop because they only calculate a single value of y(x) each time they are called. euler ( f , x_n , y_n , h ) Calculates a single point of y(x) through an aproximation using Euler's method. Parameters: f ( function ) \u2013 The function f(x,y) that appears on the right side of the differential equation. x_n ( float ) \u2013 The previous value of x, with this variable y_nph will be approximated. y_n ( float ) \u2013 The previous value of y, with this variable y_nph will be approximated. h ( float ) \u2013 The size of each step taken through the iteration that approximates the function y(x) . Returns: y_nph ( float ) \u2013 Value of the point y_nph, this value is y(x+h) . Source code in ode.py 1 2 3 4 5 6 7 8 9 10 11 12 13 def euler ( f , x_n , y_n , h ): '''Calculates a single point of \\(y(x)\\) through an aproximation using Euler's method. Args: f (function): The function f(x,y) that appears on the right side of the differential equation. x_n (float): The previous value of x, with this variable y_nph will be approximated. y_n (float): The previous value of y, with this variable y_nph will be approximated. h (float): The size of each step taken through the iteration that approximates the function \\(y(x)\\). Returns: y_nph (float): Value of the point y_nph, this value is \\(y(x+h)\\). ''' return y_n + h * f ( x_n , y_n ) rk2 ( f , x_n , y_n , h ) Calculates a single point of y(x) through an aproximation using the Runge Kutta method of second order. Parameters: f ( function ) \u2013 The function f(x,y) that appears on the right side of the differential equation. x_n ( float ) \u2013 The previous value of x, with this variable y_nph will be approximated. y_n ( float ) \u2013 The previous value of y, with this variable y_nph will be approximated. h ( float ) \u2013 The size of each step taken through the iteration that approximates the function y(x) . Returns: y_nph ( float ) \u2013 Value of the point y_nph, this value is y(x+h) . Source code in ode.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def rk2 ( f , x_n , y_n , h ): '''Calculates a single point of \\(y(x)\\) through an aproximation using the Runge Kutta method of second order. Args: f (function): The function f(x,y) that appears on the right side of the differential equation. x_n (float): The previous value of x, with this variable y_nph will be approximated. y_n (float): The previous value of y, with this variable y_nph will be approximated. h (float): The size of each step taken through the iteration that approximates the function \\(y(x)\\). Returns: y_nph (float): Value of the point y_nph, this value is \\(y(x+h)\\). ''' k1 = f ( x_n , y_n ) k2 = f ( x_n + h / 2 , y_n + k1 / 2 ) return y_n + h * k2 rk4 ( f , x_n , y_n , h ) Calculates a single point of y(x) through an aproximation using the Runge Kutta method of fourth order. Parameters: f ( function ) \u2013 The function f(x,y) that appears on the right side of the differential equation. x_n ( float ) \u2013 The previous value of x, with this variable y_nph will be approximated. y_n ( float ) \u2013 The previous value of y, with this variable y_nph will be approximated. h ( float ) \u2013 The size of each step taken through the iteration that approximates the function y(x) . Returns: y_nph ( float ) \u2013 Value of the point y_nph, this value is y(x+h) . Source code in ode.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def rk4 ( f , x_n , y_n , h ): '''Calculates a single point of \\(y(x)\\) through an aproximation using the Runge Kutta method of fourth order. Args: f (function): The function f(x,y) that appears on the right side of the differential equation. x_n (float): The previous value of x, with this variable y_nph will be approximated. y_n (float): The previous value of y, with this variable y_nph will be approximated. h (float): The size of each step taken through the iteration that approximates the function \\(y(x)\\). Returns: y_nph (float): Value of the point y_nph, this value is \\(y(x+h)\\). ''' k1 = f ( x_n , y_n ) k2 = f ( x_n + h / 2 , y_n + h / 2 * k1 ) k3 = f ( x_n + h / 2 , y_n + h / 2 * k2 ) k4 = f ( x_n + h , y_n + h * k3 ) return y_n + h / 6 * ( k1 + 2 * k2 + 2 * k3 + k4 ) step ( a , b , N ) Calculates the size of the step taken in a given interval [a,b] . Parameters: a ( float ) \u2013 Point where the interval begins. b ( float ) \u2013 Point where the interval ends. N ( int ) \u2013 Number of steps wanted in the interval. Returns: h ( float ) \u2013 Size of the steps that will be taken in the approximation of the function y(x) . Source code in ode.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def step ( a , b , N ): '''Calculates the size of the step taken in a given interval \\([a,b]\\). Args: a (float): Point where the interval begins. b (float): Point where the interval ends. N (int): Number of steps wanted in the interval. Returns: h (float): Size of the steps that will be taken in the approximation of the function \\(y(x)\\). ''' interval = linspace ( a , b , N ) return interval [ 2 ] - interval [ 1 ]","title":"How to use"},{"location":"reference.html#how-to-use","text":"Here is presented general description of how these methods were build as python functions. Its important to mention that to use correctly these methods they need to be used inside a loop because they only calculate a single value of y(x) each time they are called.","title":"How to use"},{"location":"reference.html#ode.euler","text":"Calculates a single point of y(x) through an aproximation using Euler's method. Parameters: f ( function ) \u2013 The function f(x,y) that appears on the right side of the differential equation. x_n ( float ) \u2013 The previous value of x, with this variable y_nph will be approximated. y_n ( float ) \u2013 The previous value of y, with this variable y_nph will be approximated. h ( float ) \u2013 The size of each step taken through the iteration that approximates the function y(x) . Returns: y_nph ( float ) \u2013 Value of the point y_nph, this value is y(x+h) . Source code in ode.py 1 2 3 4 5 6 7 8 9 10 11 12 13 def euler ( f , x_n , y_n , h ): '''Calculates a single point of \\(y(x)\\) through an aproximation using Euler's method. Args: f (function): The function f(x,y) that appears on the right side of the differential equation. x_n (float): The previous value of x, with this variable y_nph will be approximated. y_n (float): The previous value of y, with this variable y_nph will be approximated. h (float): The size of each step taken through the iteration that approximates the function \\(y(x)\\). Returns: y_nph (float): Value of the point y_nph, this value is \\(y(x+h)\\). ''' return y_n + h * f ( x_n , y_n )","title":"euler"},{"location":"reference.html#ode.rk2","text":"Calculates a single point of y(x) through an aproximation using the Runge Kutta method of second order. Parameters: f ( function ) \u2013 The function f(x,y) that appears on the right side of the differential equation. x_n ( float ) \u2013 The previous value of x, with this variable y_nph will be approximated. y_n ( float ) \u2013 The previous value of y, with this variable y_nph will be approximated. h ( float ) \u2013 The size of each step taken through the iteration that approximates the function y(x) . Returns: y_nph ( float ) \u2013 Value of the point y_nph, this value is y(x+h) . Source code in ode.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def rk2 ( f , x_n , y_n , h ): '''Calculates a single point of \\(y(x)\\) through an aproximation using the Runge Kutta method of second order. Args: f (function): The function f(x,y) that appears on the right side of the differential equation. x_n (float): The previous value of x, with this variable y_nph will be approximated. y_n (float): The previous value of y, with this variable y_nph will be approximated. h (float): The size of each step taken through the iteration that approximates the function \\(y(x)\\). Returns: y_nph (float): Value of the point y_nph, this value is \\(y(x+h)\\). ''' k1 = f ( x_n , y_n ) k2 = f ( x_n + h / 2 , y_n + k1 / 2 ) return y_n + h * k2","title":"rk2"},{"location":"reference.html#ode.rk4","text":"Calculates a single point of y(x) through an aproximation using the Runge Kutta method of fourth order. Parameters: f ( function ) \u2013 The function f(x,y) that appears on the right side of the differential equation. x_n ( float ) \u2013 The previous value of x, with this variable y_nph will be approximated. y_n ( float ) \u2013 The previous value of y, with this variable y_nph will be approximated. h ( float ) \u2013 The size of each step taken through the iteration that approximates the function y(x) . Returns: y_nph ( float ) \u2013 Value of the point y_nph, this value is y(x+h) . Source code in ode.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def rk4 ( f , x_n , y_n , h ): '''Calculates a single point of \\(y(x)\\) through an aproximation using the Runge Kutta method of fourth order. Args: f (function): The function f(x,y) that appears on the right side of the differential equation. x_n (float): The previous value of x, with this variable y_nph will be approximated. y_n (float): The previous value of y, with this variable y_nph will be approximated. h (float): The size of each step taken through the iteration that approximates the function \\(y(x)\\). Returns: y_nph (float): Value of the point y_nph, this value is \\(y(x+h)\\). ''' k1 = f ( x_n , y_n ) k2 = f ( x_n + h / 2 , y_n + h / 2 * k1 ) k3 = f ( x_n + h / 2 , y_n + h / 2 * k2 ) k4 = f ( x_n + h , y_n + h * k3 ) return y_n + h / 6 * ( k1 + 2 * k2 + 2 * k3 + k4 )","title":"rk4"},{"location":"reference.html#ode.step","text":"Calculates the size of the step taken in a given interval [a,b] . Parameters: a ( float ) \u2013 Point where the interval begins. b ( float ) \u2013 Point where the interval ends. N ( int ) \u2013 Number of steps wanted in the interval. Returns: h ( float ) \u2013 Size of the steps that will be taken in the approximation of the function y(x) . Source code in ode.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def step ( a , b , N ): '''Calculates the size of the step taken in a given interval \\([a,b]\\). Args: a (float): Point where the interval begins. b (float): Point where the interval ends. N (int): Number of steps wanted in the interval. Returns: h (float): Size of the steps that will be taken in the approximation of the function \\(y(x)\\). ''' interval = linspace ( a , b , N ) return interval [ 2 ] - interval [ 1 ]","title":"step"}]}